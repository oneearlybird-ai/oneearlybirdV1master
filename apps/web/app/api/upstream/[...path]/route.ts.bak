export const runtime = "edge";
import { NextRequest, NextResponse } from "next/server";
import { guardUpstream } from "@/lib/ratelimit";

const UPSTREAM = (process.env.API_UPSTREAM || "").replace(/\/+$/, "");
const _PING_PATH = process.env.API_UPSTREAM_PING_PATH || "/health";

export async function GET(req: NextRequest, { params }: { params: { path: string[] } }) {
  return proxy(req, params);
}
export async function POST(req: NextRequest, { params }: { params: { path: string[] } }) { return proxy(req, params); }
export async function PUT(req: NextRequest, { params }: { params: { path: string[] } }) { return proxy(req, params); }
export async function PATCH(req: NextRequest, { params }: { params: { path: string[] } }) { return proxy(req, params); }
export async function DELETE(req: NextRequest, { params }: { params: { path: string[] } }) { return proxy(req, params); }

async function proxy(req: NextRequest, { path }: { path: string[] }) {
  if (!UPSTREAM) return NextResponse.json({ ok: false, error: "unconfigured" }, { status: 500 });

  const { ok: allowed, headers } = await guardUpstream(req);
  if (!allowed) return new NextResponse("Too Many Requests", { status: 429, headers });

  const pathname = "/" + (path?.join("/") || "");
  const url = new URL(UPSTREAM + pathname);
  url.search = new URL(req.url).search;

  const method = req.method.toUpperCase();
  const init: RequestInit = {
    method,
    headers: stripHopByHop(req.headers),
    cache: "no-store",
    redirect: "manual",
  };
  if (method !== "GET" && method !== "HEAD") {
    // @ts-expect-error body is a ReadableStream<Uint8Array> in Edge; that's OK for fetch()
    init.body = req.body;
  }
  const upstream = await fetch(url.toString(), init);
  const respHeaders = new Headers(upstream.headers);
  respHeaders.delete("transfer-encoding");
  return new NextResponse(upstream.body, { status: upstream.status, headers: respHeaders });
}

function stripHopByHop(h: Headers): Headers {
  const out = new Headers(h);
  ["connection","keep-alive","proxy-authenticate","proxy-authorization","te","trailer","transfer-encoding","upgrade"].forEach(k=>out.delete(k));
  return out;
}
